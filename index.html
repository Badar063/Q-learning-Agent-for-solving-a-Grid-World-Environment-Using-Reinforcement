<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grid World Q-Learning</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: #1a1a2e;
            color: #e6e6e6;
            line-height: 1.6;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: linear-gradient(135deg, #16213e 0%, #0f3460 100%);
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            color: #4cc9f0;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        h2 {
            font-size: 1.8rem;
            margin: 20px 0 15px;
            color: #4cc9f0;
        }
        
        h3 {
            font-size: 1.4rem;
            margin: 15px 0 10px;
            color: #4cc9f0;
        }
        
        .info-section {
            background-color: #16213e;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 30px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }
        
        .grid-container {
            display: flex;
            flex-wrap: wrap;
            gap: 30px;
            margin-bottom: 30px;
        }
        
        .grid-world {
            background-color: #1e1e2e;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            flex: 1;
            min-width: 300px;
        }
        
        .controls {
            background-color: #1e1e2e;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            flex: 1;
            min-width: 300px;
        }
        
        .grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            grid-template-rows: repeat(5, 1fr);
            gap: 4px;
            margin: 0 auto;
            width: 400px;
            height: 400px;
        }
        
        .cell {
            border: 2px solid #4cc9f0;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            position: relative;
            background-color: #16213e;
        }
        
        .start {
            background-color: #27ae60;
        }
        
        .terminal {
            background-color: #3498db;
        }
        
        .obstacle {
            background-color: #2c3e50;
            background-image: repeating-linear-gradient(45deg, transparent, transparent 5px, rgba(0,0,0,.1) 5px, rgba(0,0,0,.1) 10px);
        }
        
        .jump {
            background-color: #e74c3c;
        }
        
        .agent {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background-color: #f1c40f;
            border: 2px solid #f39c12;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        .btn {
            background-color: #4cc9f0;
            color: #1a1a2e;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        .btn:hover {
            background-color: #3aa8d0;
            transform: translateY(-2px);
        }
        
        .btn:active {
            transform: translateY(0);
        }
        
        .btn:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
        }
        
        .slider-container {
            margin: 15px 0;
        }
        
        .slider-label {
            display: flex;
            justify-content: space-between;
        }
        
        input[type="range"] {
            width: 100%;
            margin: 10px 0;
        }
        
        .charts {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .chart-container {
            background-color: #1e1e2e;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            flex: 1;
            min-width: 300px;
            height: 300px;
        }
        
        .policy-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            grid-template-rows: repeat(5, 1fr);
            gap: 4px;
            margin: 0 auto;
            width: 400px;
            height: 400px;
        }
        
        .policy-cell {
            border: 2px solid #4cc9f0;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            background-color: #16213e;
            font-size: 24px;
        }
        
        .north { color: #e74c3c; }
        .south { color: #3498db; }
        .east { color: #27ae60; }
        .west { color: #f39c12; }
        
        .stats {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin: 20px 0;
        }
        
        .stat-box {
            background-color: #16213e;
            padding: 15px;
            border-radius: 8px;
            flex: 1;
            min-width: 200px;
            text-align: center;
        }
        
        .stat-value {
            font-size: 2rem;
            font-weight: bold;
            color: #4cc9f0;
        }
        
        footer {
            text-align: center;
            margin-top: 30px;
            padding: 20px;
            color: #6c757d;
        }
        
        @media (max-width: 768px) {
            .grid, .policy-grid {
                width: 300px;
                height: 300px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Grid World Q-Learning</h1>
            <p>Name: Badar Ul Islam | Student ID: 20036990 | Course: MSc in Computer Science and Technology</p>
            <p>Module: Deep Learning and Its Application | Professors: Dr Muhammad Akram / Dr Okunola Adebola Orogun</p>
        </header>
        
        <div class="info-section">
            <h2>Environment Overview</h2>
            <p>This interactive visualization demonstrates Q-learning in a 5x5 grid world environment with obstacles, rewards, and special jumps.</p>
            
            <div class="stats">
                <div class="stat-box">
                    <h3>Grid Size</h3>
                    <p class="stat-value">5×5</p>
                </div>
                <div class="stat-box">
                    <h3>Start State</h3>
                    <p class="stat-value">(2, 1)</p>
                </div>
                <div class="stat-box">
                    <h3>Terminal State</h3>
                    <p class="stat-value">(5, 5)</p>
                </div>
                <div class="stat-box">
                    <h3>Special Jump</h3>
                    <p class="stat-value">(2,4)→(4,4)</p>
                </div>
            </div>
        </div>
        
        <div class="grid-container">
            <div class="grid-world">
                <h2>Grid World Visualization</h2>
                <div class="grid" id="grid"></div>
            </div>
            
            <div class="controls">
                <h2>Training Controls</h2>
                
                <div class="slider-container">
                    <div class="slider-label">
                        <span>Learning Rate (α):</span>
                        <span id="learning-rate-value">0.5</span>
                    </div>
                    <input type="range" id="learning-rate" min="0.1" max="1.0" step="0.1" value="0.5">
                </div>
                
                <div class="slider-container">
                    <div class="slider-label">
                        <span>Discount Factor (γ):</span>
                        <span id="discount-value">0.9</span>
                    </div>
                    <input type="range" id="discount" min="0.1" max="0.99" step="0.01" value="0.9">
                </div>
                
                <div class="slider-container">
                    <div class="slider-label">
                        <span>Exploration (ε):</span>
                        <span id="exploration-value">0.3</span>
                    </div>
                    <input type="range" id="exploration" min="0.1" max="1.0" step="0.1" value="0.3">
                </div>
                
                <div class="slider-container">
                    <div class="slider-label">
                        <span>Training Episodes:</span>
                        <span id="episodes-value">100</span>
                    </div>
                    <input type="range" id="episodes" min="10" max="500" step="10" value="100">
                </div>
                
                <button id="train-btn" class="btn">Train Agent</button>
                <button id="reset-btn" class="btn">Reset</button>
                <button id="run-btn" class="btn">Run Optimal Policy</button>
                
                <div id="training-status">
                    <h3>Training Status: Not Started</h3>
                    <p>Episode: <span id="episode-count">0</span>/<span id="total-episodes">100</span></p>
                    <p>Current Reward: <span id="current-reward">0</span></p>
                </div>
            </div>
        </div>
        
        <div class="charts">
            <div class="chart-container">
                <canvas id="reward-chart"></canvas>
            </div>
            <div class="chart-container">
                <canvas id="steps-chart"></canvas>
            </div>
        </div>
        
        <div class="info-section">
            <h2>Optimal Policy</h2>
            <p>The policy below shows the best action to take in each state according to the learned Q-values.</p>
            <div class="policy-grid" id="policy-grid"></div>
        </div>
        
        <footer>
            <p>Ulster University | Deep Learning and Its Application | Q-Learning Implementation</p>
        </footer>
    </div>

    <script>
        // Grid World Environment
        class GridWorld {
            constructor() {
                this.rows = 5;
                this.cols = 5;
                this.start_state = [2, 1];
                this.terminal_state = [5, 5];
                this.special_jump = { '2,4': [4, 4] };
                this.obstacles = ['3,3', '3,4', '3,5', '4,3'];
                
                this.actions = [1, 2, 3, 4];
                this.action_names = {1: 'North', 2: 'South', 3: 'East', 4: 'West'};
                this.action_deltas = {
                    1: [-1, 0],  // North
                    2: [1, 0],   // South
                    3: [0, 1],   // East
                    4: [0, -1]   // West
                };
            }
            
            is_valid_state(state) {
                const [row, col] = state;
                return (row >= 1 && row <= this.rows && 
                        col >= 1 && col <= this.cols && 
                        !this.obstacles.includes(`${row},${col}`));
            }
            
            get_next_state(state, action) {
                const [row, col] = state;
                const stateKey = `${row},${col}`;
                
                // Check for special jump
                if (this.special_jump[stateKey]) {
                    return {
                        nextState: this.special_jump[stateKey],
                        reward: 5,
                        done: false
                    };
                }
                
                // Check if terminal state
                if (row === this.terminal_state[0] && col === this.terminal_state[1]) {
                    return {
                        nextState: state,
                        reward: 0,
                        done: true
                    };
                }
                
                // Calculate movement
                const [dRow, dCol] = this.action_deltas[action];
                const nextState = [row + dRow, col + dCol];
                
                // Check if valid
                if (!this.is_valid_state(nextState)) {
                    return {
                        nextState: state,
                        reward: -1,
                        done: false
                    };
                }
                
                // Check if terminal state after move
                if (nextState[0] === this.terminal_state[0] && nextState[1] === this.terminal_state[1]) {
                    return {
                        nextState: nextState,
                        reward: 10,
                        done: true
                    };
                }
                
                return {
                    nextState: nextState,
                    reward: -1,
                    done: false
                };
            }
            
            reset() {
                return [...this.start_state];
            }
        }

        // Q-Learning Agent
        class QLearningAgent {
            constructor(env, learning_rate = 0.5, discount_factor = 0.9, epsilon = 0.3) {
                this.env = env;
                this.learning_rate = learning_rate;
                this.discount_factor = discount_factor;
                this.epsilon = epsilon;
                
                // Initialize Q-table (6x6x4 to account for 1-indexed states)
                this.q_table = Array(6).fill().map(() => 
                    Array(6).fill().map(() => 
                        Array(4).fill(0)
                    )
                );
                
                this.episode_rewards = [];
                this.episode_lengths = [];
            }
            
            choose_action(state, training = true) {
                const [row, col] = state;
                
                if (training && Math.random() < this.epsilon) {
                    // Exploration: choose a random valid action
                    const valid_actions = [];
                    for (const action of this.env.actions) {
                        const result = this.env.get_next_state(state, action);
                        if (result.nextState[0] !== state[0] || result.nextState[1] !== state[1]) {
                            valid_actions.push(action);
                        }
                    }
                    
                    if (valid_actions.length > 0) {
                        return valid_actions[Math.floor(Math.random() * valid_actions.length)];
                    } else {
                        return this.env.actions[Math.floor(Math.random() * this.env.actions.length)];
                    }
                } else {
                    // Exploitation: choose the best action
                    const actionValues = this.q_table[row][col];
                    let maxVal = -Infinity;
                    let bestActions = [];
                    
                    for (let i = 0; i < actionValues.length; i++) {
                        if (actionValues[i] > maxVal) {
                            maxVal = actionValues[i];
                            bestActions = [i];
                        } else if (actionValues[i] === maxVal) {
                            bestActions.push(i);
                        }
                    }
                    
                    // Return a random action among the best ones
                    return this.env.actions[bestActions[Math.floor(Math.random() * bestActions.length)]];
                }
            }
            
            update_q_value(state, action, reward, next_state) {
                const [row, col] = state;
                const [next_row, next_col] = next_state;
                const action_idx = this.env.actions.indexOf(action);
                
                let next_max_q = 0;
                if (!(next_row === this.env.terminal_state[0] && next_col === this.env.terminal_state[1])) {
                    next_max_q = Math.max(...this.q_table[next_row][next_col]);
                }
                
                // Q-learning update rule
                this.q_table[row][col][action_idx] += this.learning_rate * (
                    reward + this.discount_factor * next_max_q - this.q_table[row][col][action_idx]
                );
            }
            
            get_state_values() {
                const state_values = Array(6).fill().map(() => Array(6).fill(0));
                for (let row = 1; row <= 5; row++) {
                    for (let col = 1; col <= 5; col++) {
                        if (this.env.obstacles.includes(`${row},${col}`)) {
                            state_values[row][col] = null;
                        } else {
                            state_values[row][col] = Math.max(...this.q_table[row][col]);
                        }
                    }
                }
                return state_values;
            }
            
            get_policy() {
                const policy = {};
                for (let row = 1; row <= 5; row++) {
                    for (let col = 1; col <= 5; col++) {
                        if (!this.env.obstacles.includes(`${row},${col}`)) {
                            const actionValues = this.q_table[row][col];
                            const bestActionIndex = actionValues.indexOf(Math.max(...actionValues));
                            policy[`${row},${col}`] = this.env.actions[bestActionIndex];
                        }
                    }
                }
                return policy;
            }
        }

        // Initialize environment and agent
        const env = new GridWorld();
        let agent = new QLearningAgent(env);
        let isTraining = false;
        let currentEpisode = 0;
        let currentState = env.reset();
        let rewardChart, stepsChart;

        // Initialize the grid visualization
        function initializeGrid() {
            const grid = document.getElementById('grid');
            grid.innerHTML = '';
            
            for (let row = 5; row >= 1; row--) {
                for (let col = 1; col <= 5; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.id = `cell-${row}-${col}`;
                    cell.innerHTML = `(${row},${col})`;
                    
                    // Mark special cells
                    if (row === env.start_state[0] && col === env.start_state[1]) {
                        cell.classList.add('start');
                        cell.innerHTML = 'Start';
                    } else if (row === env.terminal_state[0] && col === env.terminal_state[1]) {
                        cell.classList.add('terminal');
                        cell.innerHTML = 'Terminal<br>+10';
                    } else if (env.obstacles.includes(`${row},${col}`)) {
                        cell.classList.add('obstacle');
                        cell.innerHTML = 'X';
                    } else if (env.special_jump[`${row},${col}`]) {
                        cell.classList.add('jump');
                        cell.innerHTML = 'Jump<br>+5';
                    }
                    
                    grid.appendChild(cell);
                }
            }
            
            updateAgentPosition();
        }

        // Update agent position on the grid
        function updateAgentPosition() {
            // Remove any existing agent
            document.querySelectorAll('.agent').forEach(el => el.remove());
            
            const [row, col] = currentState;
            const cell = document.getElementById(`cell-${row}-${col}`);
            if (cell) {
                const agentEl = document.createElement('div');
                agentEl.className = 'agent';
                cell.appendChild(agentEl);
            }
        }

        // Initialize policy grid
        function initializePolicyGrid() {
            const policyGrid = document.getElementById('policy-grid');
            policyGrid.innerHTML = '';
            
            for (let row = 5; row >= 1; row--) {
                for (let col = 1; col <= 5; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'policy-cell';
                    cell.id = `policy-cell-${row}-${col}`;
                    
                    if (row === env.start_state[0] && col === env.start_state[1]) {
                        cell.innerHTML = 'Start';
                    } else if (row === env.terminal_state[0] && col === env.terminal_state[1]) {
                        cell.innerHTML = 'End';
                    } else if (env.obstacles.includes(`${row},${col}`)) {
                        cell.innerHTML = 'X';
                    } else if (env.special_jump[`${row},${col}`]) {
                        cell.innerHTML = 'Jump';
                    } else {
                        cell.innerHTML = '?';
                    }
                    
                    policyGrid.appendChild(cell);
                }
            }
        }

        // Update policy grid display
        function updatePolicyGrid() {
            const policy = agent.get_policy();
            const actionSymbols = {1: '↑', 2: '↓', 3: '→', 4: '←'};
            const actionClasses = {1: 'north', 2: 'south', 3: 'east', 4: 'west'};
            
            for (let row = 1; row <= 5; row++) {
                for (let col = 1; col <= 5; col++) {
                    const cell = document.getElementById(`policy-cell-${row}-${col}`);
                    if (cell) {
                        const stateKey = `${row},${col}`;
                        if (policy[stateKey]) {
                            cell.innerHTML = actionSymbols[policy[stateKey]];
                            cell.classList.add(actionClasses[policy[stateKey]]);
                        }
                    }
                }
            }
        }

        // Initialize charts
        function initializeCharts() {
            const rewardCtx = document.getElementById('reward-chart').getContext('2d');
            rewardChart = new Chart(rewardCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Episode Reward',
                        data: [],
                        borderColor: '#4cc9f0',
                        backgroundColor: 'rgba(76, 201, 240, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            grid: {
                                color: 'rgba(255, 255, 255, 0.1)'
                            },
                            ticks: {
                                color: '#e6e6e6'
                            }
                        },
                        x: {
                            grid: {
                                color: 'rgba(255, 255, 255, 0.1)'
                            },
                            ticks: {
                                color: '#e6e6e6'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            labels: {
                                color: '#e6e6e6'
                            }
                        }
                    }
                }
            });
            
            const stepsCtx = document.getElementById('steps-chart').getContext('2d');
            stepsChart = new Chart(stepsCtx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Steps per Episode',
                        data: [],
                        borderColor: '#e74c3c',
                        backgroundColor: 'rgba(231, 76, 60, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            grid: {
                                color: 'rgba(255, 255, 255, 0.1)'
                            },
                            ticks: {
                                color: '#e6e6e6'
                            }
                        },
                        x: {
                            grid: {
                                color: 'rgba(255, 255, 255, 0.1)'
                            },
                            ticks: {
                                color: '#e6e6e6'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            labels: {
                                color: '#e6e6e6'
                            }
                        }
                    }
                }
            });
        }

        // Update charts with new data
        function updateCharts(episode, reward, steps) {
            rewardChart.data.labels.push(episode);
            rewardChart.data.datasets[0].data.push(reward);
            rewardChart.update();
            
            stepsChart.data.labels.push(episode);
            stepsChart.data.datasets[0].data.push(steps);
            stepsChart.update();
        }

        // Train the agent
        async function trainAgent() {
            if (isTraining) return;
            
            isTraining = true;
            document.getElementById('train-btn').disabled = true;
            document.getElementById('run-btn').disabled = true;
            document.getElementById('reset-btn').disabled = true;
            
            const learningRate = parseFloat(document.getElementById('learning-rate').value);
            const discountFactor = parseFloat(document.getElementById('discount').value);
            const exploration = parseFloat(document.getElementById('exploration').value);
            const episodes = parseInt(document.getElementById('episodes').value);
            
            // Update agent parameters
            agent.learning_rate = learningRate;
            agent.discount_factor = discountFactor;
            agent.epsilon = exploration;
            
            agent.episode_rewards = [];
            agent.episode_lengths = [];
            
            // Reset charts
            rewardChart.data.labels = [];
            rewardChart.data.datasets[0].data = [];
            rewardChart.update();
            
            stepsChart.data.labels = [];
            stepsChart.data.datasets[0].data = [];
            stepsChart.update();
            
            document.getElementById('total-episodes').textContent = episodes;
            
            for (let episode = 0; episode < episodes; episode++) {
                if (!isTraining) break;
                
                currentEpisode = episode + 1;
                let state = env.reset();
                let totalReward = 0;
                let steps = 0;
                let done = false;
                
                document.getElementById('episode-count').textContent = currentEpisode;
                
                while (!done && steps < 100) {
                    const action = agent.choose_action(state);
                    const { nextState, reward, done: isDone } = env.get_next_state(state, action);
                    
                    agent.update_q_value(state, action, reward, nextState);
                    
                    state = nextState;
                    totalReward += reward;
                    steps++;
                    done = isDone;
                    
                    // Update visualization occasionally for the first few episodes
                    if (episode < 3 && steps % 2 === 0) {
                        currentState = state;
                        updateAgentPosition();
                        document.getElementById('current-reward').textContent = totalReward;
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }
                }
                
                agent.episode_rewards.push(totalReward);
                agent.episode_lengths.push(steps);
                
                document.getElementById('current-reward').textContent = totalReward;
                updateCharts(currentEpisode, totalReward, steps);
                
                // Update policy display every 10 episodes
                if (currentEpisode % 10 === 0) {
                    updatePolicyGrid();
                }
                
                // Slow down training for visualization
                await new Promise(resolve => setTimeout(resolve, 10));
            }
            
            updatePolicyGrid();
            document.getElementById('training-status').innerHTML = '<h3>Training Status: Completed</h3>';
            
            document.getElementById('train-btn').disabled = false;
            document.getElementById('run-btn').disabled = false;
            document.getElementById('reset-btn').disabled = false;
            isTraining = false;
        }

        // Run the optimal policy
        async function runOptimalPolicy() {
            if (isTraining) return;
            
            document.getElementById('run-btn').disabled = true;
            document.getElementById('train-btn').disabled = true;
            
            currentState = env.reset();
            updateAgentPosition();
            
            let done = false;
            let steps = 0;
            
            while (!done && steps < 50) {
                const action = agent.choose_action(currentState, false); // No exploration
                const { nextState, reward, done: isDone } = env.get_next_state(currentState, action);
                
                currentState = nextState;
                done = isDone;
                steps++;
                
                updateAgentPosition();
                await new Promise(resolve => setTimeout(resolve, 500));
            }
            
            document.getElementById('run-btn').disabled = false;
            document.getElementById('train-btn').disabled = false;
        }

        // Reset the environment and agent
        function resetEnvironment() {
            if (isTraining) {
                isTraining = false;
                setTimeout(resetEnvironment, 100);
                return;
            }
            
            currentState = env.reset();
            agent = new QLearningAgent(env);
            
            document.getElementById('learning-rate').value = 0.5;
            document.getElementById('discount').value = 0.9;
            document.getElementById('exploration').value = 0.3;
            document.getElementById('episodes').value = 100;
            
            document.getElementById('learning-rate-value').textContent = 0.5;
            document.getElementById('discount-value').textContent = 0.9;
            document.getElementById('exploration-value').textContent = 0.3;
            document.getElementById('episodes-value').textContent = 100;
            
            document.getElementById('episode-count').textContent = 0;
            document.getElementById('current-reward').textContent = 0;
            document.getElementById('training-status').innerHTML = '<h3>Training Status: Not Started</h3>';
            
            rewardChart.data.labels = [];
            rewardChart.data.datasets[0].data = [];
            rewardChart.update();
            
            stepsChart.data.labels = [];
            stepsChart.data.datasets[0].data = [];
            stepsChart.update();
            
            initializePolicyGrid();
            updateAgentPosition();
            
            document.getElementById('train-btn').disabled = false;
            document.getElementById('run-btn').disabled = false;
        }

        // Initialize the application
        function initializeApp() {
            initializeGrid();
            initializePolicyGrid();
            initializeCharts();
            updateAgentPosition();
            
            // Add event listeners
            document.getElementById('train-btn').addEventListener('click', trainAgent);
            document.getElementById('run-btn').addEventListener('click', runOptimalPolicy);
            document.getElementById('reset-btn').addEventListener('click', resetEnvironment);
            
            // Update slider values
            document.getElementById('learning-rate').addEventListener('input', function() {
                document.getElementById('learning-rate-value').textContent = this.value;
            });
            
            document.getElementById('discount').addEventListener('input', function() {
                document.getElementById('discount-value').textContent = this.value;
            });
            
            document.getElementById('exploration').addEventListener('input', function() {
                document.getElementById('exploration-value').textContent = this.value;
            });
            
            document.getElementById('episodes').addEventListener('input', function() {
                document.getElementById('episodes-value').textContent = this.value;
            });
        }

        // Start the application when the page loads
        window.addEventListener('load', initializeApp);
    </script>
</body>
</html>